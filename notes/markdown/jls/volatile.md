##### volatile的原理
- volatile 会加入内存屏障从而阻止重排序
    1. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成,在其后面的操作肯定还没有进行。
    2. 它会强制将对缓存的修改操作立即写入主存；
    3. 如果是写操作，它会导致其他CPU中对应的缓存行无效。
- “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”, lock前缀指令实际上相当于一个内存屏障    
- 内存屏障有三种类型和一种伪类型：
lfence：即读屏障(Load Barrier)，在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据，以保证读取的是最新的数据。
sfence：即写屏障(Store Barrier)，在写指令之后插入写屏障，能让写入缓存的最新数据写回到主内存，以保证写入的数据立刻对其他线程可见。
mfence，即全能屏障，具备ifence和sfence的能力。
Lock前缀：Lock不是一种内存屏障，但是它能完成类似全能型内存屏障的功能
##### 两层语义
- 变量被volatile修饰后
    - 可见性：即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的
    - 禁止进行指令重排序
##### volatile不保证原子性
- 被volatile修饰的int变量进行(++)操作不能保证线程安全， volatile不保证原子性，(++)操作也不是原子操作
- 如线程A读完变量后但在修改之前B线程修改了该变量，此处A线程因为已经读了不会再去读，修改是基于旧的值进行的

##### 应用场景
- 可以被写入volatile变量的有效值独立于任何程序的状态，包括变量的当前状态
- 必须具备以下2个条件：
    1. 对变量的写操作不依赖于当前值(当前状态)
    2. 该变量没有包含在具有其他变量的不变式中
- 违背以上条件需要保证操作是原子性操作，才能保证使用volatile关键字的并发安全
- 具体场景 
    - 状态标记量
    - double check单例